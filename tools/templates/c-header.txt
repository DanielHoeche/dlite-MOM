/* This file is generated with dlite-codegen {dlite.version} -- do not edit!
 *
 * Template: c-header.txt
 * Metadata: {meta.uri}
 *
 * This file declares the struct `{name}` with the dimensions and
 * properties of the dlite metadata it was generated from. It can be
 * included and used in your project without any dependencies (except
 * for the header files boolean.h, integers.h and floats.h that are
 * provided with dlite).
 *
 * However it is beneficial to use it together with the dlite library,
 * e.g. for letting dlite handle I/O.  In that case you should either
 * define the macro HAVE_DLITE or including "dlite.h" before including
 * this header.  Instances of `{name}` are valid dlite instances and
 * can safely be casted to `DLiteInstance`.
 *
 * It is also possible to define an extended metadata struct with
 * custom fields.  It that case you should define the macro
 * CUSTOM_{name%U} before including this header to suppress the
 * default definition of the struct `{name}`.  Instead you should
 * define it yourself, like
 *
 *     typedef struct _{name} {{
 *       {name}_HEAD
 *       <my fields>...
 *       {name}_TAIL
 *     }} {name};
 *
 * where <my fields> are any additional fields for internal data you
 * for {name}.  If you do this, remember to update the metadata using
 * the DLITE_UPDATE_EXTENEDE_META() macro before loading/creating any
 * instances.
 */

/**
  @file
  @brief {descr}
*/
#ifndef _{name%U}_H
#define _{name%U}_H

#include "utils/integers.h"
#include "utils/boolean.h"
#include "utils/floats.h"

#define {name%U}_NAME      "{name}"
#define {name%U}_VERSION   "{version}"
#define {name%U}_NAMESPACE "{namespace}"
#define {name%U}_URI       "{_uri}"
#define {name%U}_UUID      "{_uuid}"
#define {name%U}_META_URI  "{meta.uri}"
#define {name%U}_META_UUID "{meta.uuid}"
#define {name%U}_IRI       "{_iri}"


/* Minimal set of typedefs in case we don't have dlite */
#if defined(HAVE_DLITE)
#include "dlite.h"
#elif ! defined(DLITE_MINIMAL_DEFS)
#define DLITE_MINIMAL_DEFS
typedef enum {{dliteBlob, dliteBool, dliteInt, dliteUInt, dliteFloat,
              dliteFixString, dliteStringPtr,
                   dliteDimension, dliteProperty, dliteRelation}} DLiteType;
typedef struct {{ char *name, description; }} DLiteDimension;
typedef struct {{
  char *name;
  DLiteType type;
  size_t size;
  int ndims;
  char **dims, *unit, *iri, *description;
}} DLiteProperty;
typedef void DLiteInstance;
#endif


#ifdef HAVE_DLITE
/* FIXME - reuse DLiteInstance_HEAD/DLiteMeta_HEAD instead of redefining */
{@if:{ismetameta}=1}\
//# define {name}_HEAD DLiteMeta_HEAD
{@else}\
//# define {name}_HEAD DLiteInstance_HEAD
{@endif}\

#define {name}_HEAD  {@40}\\
  /* -- header */                       \\
  char _uuid[36+1];                     \\
  const char *_uri;                     \\
  size_t _refcount;                     \\
  const DLiteMeta *meta;                \\
  const char *_iri;                     \\
{@if:{ismetameta}=1}\
                                        \\
  size_t _ndimensions;                  \\
  size_t _nproperties;                  \\
  size_t _nrelations;                   \\
                                        \\
  DLiteDimension *_dimensions;          \\
  DLiteProperty *_properties;           \\
  DLiteRelation *_relations;            \\
                                        \\
  size_t _headersize;                   \\
  int (*_init)(DLiteInstance *inst);    \\
  int (*_deinit)(DLiteInstance *inst);  \\
                                        \\
  size_t _npropdims;                    \\
  size_t *_propdiminds;                 \\
                                        \\
  size_t _dimoffset;                    \\
  size_t *_propoffsets;                 \\
  size_t _reloffset;                    \\
  size_t _propdimsoffset;               \\
  size_t _propdimindsoffset;            \\
{@endif} \

#else
# define {name}_HEAD
#endif


#define {name}_VALUES              {@78}\\
  /* -- dimension values */        {@78}\\
{list_dimensions:  size_t {dim.name}; {@30}/* {dim.descr} */{@78}\\\n} {@78}\\
  /* -- property values */         {@78}\\
{list_properties:  {prop.cdecl}; {@30}/* {prop.descr} {@if:{prop.ndims}!0}; [{prop.dims:{dim.name}{,}\.}]{@endif} */{@78}\\\n} \
{@if:{_nrelations}!0}              {@78}\\
  /* -- relation values */         {@78}\\
  DLiteRelation __relations[{_nrelations}];
{@endif} \


#ifdef HAVE_DLITE
#define {name}_ENDTAIL \\
  /* -- __propdims: property dimension values */ \\
  size_t __propdims[{_npropdims}]; \
{@if:{ismetameta}=1} \\
  /* -- __propdiminds: index of first dimension for each property */ \\
  size_t __propdiminds[{_nproperties}]; \\
  /* -- __propoffsets */ \\
  size_t __propoffsets[{_nproperties}];
{@endif} \

#else
#define {name}_ENDTAIL
#endif


#define {name}_TAIL \\
  {name}_VALUES {name}_ENDTAIL


#ifndef CUSTOM_{name%U}
typedef struct _{name} {{
  {name}_HEAD

  /* -- dimension values */
{list_dimensions:  size_t {dim.name}; {@30}/* {dim.descr} */\n}
  /* -- property values */
{list_properties:  {prop.cdecl}; {@30}/* {prop.descr} {@if:{prop.ndims}!0}; [{prop.dims:{dim.name}{,}\.}]{@endif} */\n} \
{@if:{_nrelations}!0}
  /* -- relation values */
  DLiteRelation __relations[{_nrelations}];
{@endif} \

 {name}_ENDTAIL
}} {name};
#endif

#endif /* _{name%U}_H */
