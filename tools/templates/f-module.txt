! -*- F90 -*- (not really, but good for syntax highlighting)
!
! This file is generated with dlite-codegen {dlite.version} -- do not edit!
!
! Template: f-module.txt
! Source:   {_uri}
!
! Fortran interface to {name%M} entity from {name}.json
!
MODULE {name%M}
  USE iso_c_binding, only : c_ptr, c_int, c_char, c_null_char, &
       c_size_t, c_null_ptr, c_loc, c_f_pointer, c_associated, &
       c_int8_t, c_int16_t, c_int32_t, c_int64_t, &
       c_float, c_double, c_long_double
  USE c_interface, only: c_f_string, c_strlen_safe, f_c_string
  USE DLite

  IMPLICIT NONE
  PRIVATE

  PUBLIC :: T{name%M}
  PUBLIC :: create_meta_{name%u}

  TYPE T{name%M}
     type(c_ptr)                    :: cinst
     !character(len=36)              :: uuid
     ! dimensions
{list_dimensions:     integer(8){@36} :: {dim.name}\n}
     ! properties
{list_properties:     {prop.fdecl}\n}
   contains
     procedure :: check => check{name%M}
     procedure :: writeToURL => write{name%M}ToURL
     procedure :: writeToSource => write{name%M}ToSource
     procedure :: writeToStorage => write{name%M}ToStorage
  END TYPE T{name%M}

  INTERFACE T{name%M}
    ! read a person from an url
    module procedure read{name%M}FromURL
    ! read a person from a data source (open and close the storage)
    module procedure read{name%M}FromSource
    ! read a person from a open storage
    module procedure read{name%M}FromStorage
    ! create a person and allocate the arrays
    module procedure create{name%M}32
    ! create a person and allocate the arrays
    module procedure create{name%M}64
  END INTERFACE T{name%M}

CONTAINS

  function create_meta_{name%u}() result(meta)
    type(DLiteMeta)      :: meta
    type(DLiteMetaModel) :: model
    integer              :: i

    model = DLiteMetaModel('{uri}', '{meta.uri}', '')
    i = model%add_string('description', '{descr}')
{list_dimensions:    i = model%add_dimension('{dim.name}', '{dim.descr}')\n}\
{list_properties:    i = model%add_property(\
'{prop.name}', '{prop.type}', '{prop.unit}', '{prop.iri}', '{prop.descr}')\n\
{prop.dims:    i = model%add_property_dim('{prop.name}', '{dim.name}')\n}\
}\
    meta = DLiteMeta(model)
    call model%destroy()
  end function create_meta_{name%u}

  function create{name%M}32(n, m) result({name%u})
    implicit none
    type(T{name%M})          :: {name%u}
{list_dimensions:    integer(4), intent(in) :: {dim.name}\n}\
{list_dimensions:    {name%u}%{dim.name} = {dim.name}\n}\
{list_properties:{prop.dims:\
    allocate({name%u}%{prop.name}({dim.name}))\n}\.}\
  end function create{name%M}32

  function create{name%M}64(n, m) result({name%u})
    implicit none
    type(T{name%M})          :: {name%u}
{list_dimensions:    integer(8), intent(in) :: {dim.name}\n}\
{list_dimensions:    {name%u}%{dim.name} = {dim.name}\n}\
{list_properties:{prop.dims:\
    allocate({name%u}%{prop.name}({dim.name}))\n}\.}\
  end function create{name%M}64

  function {name%m}ToInstance({name%u}) result(instance)
    implicit none
    class(T{name%M}), intent(in)      :: {name%u}
    type(DLiteInstance)             :: instance
    type(c_ptr)                     :: cptr
{list_properties:    {prop.fptrdecl}\n}
    integer(8)                      :: nstring, strlen, i
    ! create new DLiteInstance
    instance = DLiteInstance('{uri}', &
         [{name%u}%n, {name%u}%m], '')
{list_properties:    ! {prop.name%u}\n\
    !call xxx\n}




    ! name
    call f_c_string(person%name, instance%get_property_by_index(0))
    ! age
    cptr = instance%get_property_by_index(1)
    call c_f_pointer(cptr, age_f)
    age_f = person%age
      ! skills
    cptr = instance%get_property_by_index(2)
    nstring = person%n
    strlen = 10
    call c_f_pointer(cptr, skills_f, [strlen, nstring])
    do i = 1, nstring
      call f_c_string(person%skills(i), skills_f(:,i))
    end do
    ! temperature
    cptr = instance%get_property_by_index(3)
    call c_f_pointer(cptr, temperature_f, (/person%m/))
    temperature_f = person%temperature
    !instance%cinst = person%cinst
  end function personToInstance

  ! Copy C data (DLiteInstance::instance) in Fortran type (TPerson::person)
  subroutine assignPerson(person, instance)
    implicit none
    type(TPerson), intent(inout)            :: person
    class(DLiteInstance), intent(in)        :: instance
    type(c_ptr)                             :: cptr
    real(c_float), pointer                  :: age_f
    character(kind=c_char), pointer         :: skills_f(:,:)
    real(c_float), pointer                  :: temperature_f(:)

    integer(8)                              :: nstring, strlen, i

    if (instance%check()) then
      person%cinst = instance%cinst
      !person%uuid = instance%uuid
      person%n = instance%get_dimension_size_by_index(0)
      person%m = instance%get_dimension_size_by_index(1)
      ! name
      cptr = instance%get_property_by_index(0)
      call c_f_string(cptr, person%name)
      ! age
      cptr = instance%get_property_by_index(1)
      call c_f_pointer(cptr, age_f)
      person%age = age_f
      ! skills
      cptr = instance%get_property_by_index(2)
      nstring = person%n
      strlen = 10
      call c_f_pointer(cptr, skills_f, [strlen, nstring])
      allocate(person%skills(nstring))
      do i = 1, nstring
        call c_f_string(skills_f(:,i), person%skills(i))
      end do
      ! temperature
      cptr = instance%get_property_by_index(3)
      call c_f_pointer(cptr, temperature_f, (/person%m/))
      person%temperature = temperature_f
    else
      person%cinst = c_null_ptr
    end if
  end subroutine assignPerson

  function checkPerson(person) result(status)
    implicit none
    class(TPerson), intent(in) :: person
    logical                    :: status
    status = c_associated(person%cinst)
  end function checkPerson

  function readPersonFromURL(url) result(person)
    implicit none
    character(len=*), intent(in)    :: url
    type(TPerson)                   :: person
    type(DLiteInstance)             :: instance
    instance = DLiteInstance(url)
    call assignPerson(person, instance)
  end function readPersonFromURL

  function readPersonFromSource(driver, location, options, uid) result(person)
    implicit none
    character(len=*), intent(in) :: driver
    character(len=*), intent(in) :: location
    character(len=*), intent(in) :: options
    character(len=*), intent(in) :: uid
    type(TPerson)                :: person
    type(DLiteStorage)           :: storage
    integer                      :: status
    storage = DLiteStorage(driver, location, options)
    person = readPersonFromStorage(storage, uid)
    status = storage%close()
  end function readPersonFromSource

  function readPersonFromStorage(storage, uid) result(person)
    implicit none
    type(DLiteStorage), intent(in) :: storage
    character(len=*), intent(in)    :: uid
    type(TPerson)                   :: person
    type(DLiteInstance)             :: instance
    instance = DLiteInstance(storage, uid)
    call assignPerson(person, instance)
  end function readPersonFromStorage

  function writePersonToURL(person, url) result(status)
    implicit none
    class(TPerson), intent(in)     :: person
    character(len=*), intent(in)   :: url
    type(DLiteInstance)            :: instance
    integer                        :: status
    instance = personToInstance(person)
    status = instance%save_url(url)
  end function writePersonToURL

  function writePersonToSource(person, driver, location, options) result(status)
    implicit none
    class(TPerson), intent(in)   :: person
    character(len=*), intent(in) :: driver
    character(len=*), intent(in) :: location
    character(len=*), intent(in) :: options
    type(DLiteStorage)           :: storage
    integer                      :: status, status2
    storage = DLiteStorage(driver, location, options)
    status = person%writeToStorage(storage)
    status2 = storage%close()
  end function writePersonToSource

  function writePersonToStorage(person, storage) result(status)
    implicit none
    class(TPerson), intent(in)     :: person
    type(DLiteStorage), intent(in) :: storage
    type(DLiteInstance)            :: instance
    integer                        :: status
    instance = personToInstance(person)
    status = instance%save(storage)
  end function writePersonToStorage

END MODULE Person
