/* This file is generated with dlite-codegen -- do not edit!
 *
 * Template: c-source.txt
 * Metadata: {_uri}
 *
 * This file instantiate a hardcoded instance of metadata {meta.name}.
 *
 * This allows you to use instances of {name} without first loading
 * the corresponding json file defining {name}.  For specialised instances
 * who's header is generated with the c-ext_header.txt template, one
 * should instantiate the corresponding metadata using the c-source.txt
 * template.
 *
 * Common variables that should be set when using this template:
 *
 *     meta.header
 *         Name of corresponding header file generated with c-header.txt
 *     _headersize (optional)
 *         Header size for extended header.  Typically specified using
 *         offsetof().
 *     _init (optional)
 *         Name of init() function
 *     _deinit (optional)
 *         Name of deinit() function
 */
#include <stddef.h>


/* Minimal set of typedefs in case we don't have dlite */
#if defined(HAVE_DLITE)
#include "dlite.h"
#elif ! defined(DLITE_MINIMAL_DEFS)
#define DLITE_MINIMAL_DEFS
typedef enum {{dliteBlob, dliteBool, dliteInt, dliteUInt, dliteFloat,
              dliteFixString, dliteStringPtr,
                   dliteDimension, dliteProperty, dliteRelation}} DLiteType;
typedef struct {{ char *name, *description; }} DLiteDimension;
typedef struct {{
  char *name;
  DLiteType type;
  size_t size;
  int ndims;
  char **dims, *unit, *iri, *description;
}} DLiteProperty;
typedef void DLiteInstance;
#endif

#include "{header}"
#include "{meta.header}"


{@if:{ismeta}=1}
static DLiteDimension {name}_dimensions[] = {{
{list_meta_dimensions:  {{"{dim.name}", "{dim.descr}"}}{,}\n}\
}};
{list_meta_properties:\
{@if:{prop.ndims}!0}\
static char *{basename}_prop_{prop.name}_dims[] = {{\
{prop.dims:"{dim.name}"{, }\.}\
}};
{@endif}\.}\
static DLiteProperty {name}_properties[] = {{
{list_meta_properties:  {{
    "{prop.name}", {@40}/* name */
    {prop.dtype},  {@40}/* type */
    {prop.size},   {@40}/* size */
    {prop.ndims},  {@40}/* ndims */
{@if:{prop.ndims}=0}\
    NULL,          {@40}/* dims */
{@else}\
    {basename}_prop_{prop.name}_dims, {@40}/* dims */
{@endif}\
{@if:{?prop.unit}\.}\
    "{prop.unit}", {@40}/* unit */
{@else}\
    NULL,          {@40}/* unit */
{@endif}\
{@if:{?prop.iri}\.}\
    "{prop.iri}",  {@40}/* iri */
{@else}\
    NULL,          {@40}/* iri */
{@endif}\
{@if:{?prop.descr}\.}\
    "{prop.descr}" {@40}/* description */
{@else}\
    NULL           {@40}/* description */
{@endif}\
  }}{,}
}\
}};
{@endif}\


static {meta.name} {basename} = {{
#ifdef HAVE_DLITE
  /* -- header */
  "{_uuid}",  {@52}/* _uuid */
  "{_uri}",   {@52}/* _uri */
  1,                        {@52}/* _refcount */
  NULL,                     {@52}/* _meta */
  "{_iri}",                 {@52}/* _iri */
{@if:{ismeta}=1}
  {_ndimensions},           {@52}/* _ndimensions */
  {_nproperties},           {@52}/* _nproperties */
  {_nrelations},            {@52}/* _nrelations */

  {name}_dimensions,        {@52}/* _dimensions */
  {name}_properties,        {@52}/* _properties */
  NULL,                     {@52}/* _relations */

  offsetof({name}, {list_dimensions:{@if:{dim.i}=0}{dim.name}{@endif}\.}), {@52}/* _headersize */
  {_init},                  {@52}/* _init */
  {_deinit},                {@52}/* _deinit */

  {_npropdims},             {@52}/* _npropdims */
  {basename}.__propdiminds, {@52}/* _propdiminds */

  {_dimoffset},             {@52}/* _dimoffset */
  {basename}.__propoffsets, {@52}/* _propoffsets */
  {_reloffset},             {@52}/* _reloffset */
  {_propdimsoffset},        {@52}/* _propdimsoffset */
  {_propdimindsoffset},     {@52}/* _propdimindsoffset */
{@endif}\
#endif

  /* -- length of each dimension */
{list_meta_dimensions:  {dim.value}, {@52}/* {dim.name} */\n}\

  /* -- value of each property */
{list_meta_properties:  {prop.cvalue}, {@52}/* {prop.name} */\n}\

  /* -- value of each relation */
{list_meta_relations:  {{"{rel.s}", "{rel.p}", "{rel.o}", "{rel.id}"}}{,}\n}\

#ifdef HAVE_DLITE
  /* -- __propdims: evaluated values of property dimensions */
  {{ {list_propdims:{propdim.n}{, }\.} }},
{@if:{ismeta}=1}\
  /* -- __propdiminds: index of first dimension for each property in instance */
  {{ {list_meta_properties:{prop.dimind}{, }\.} }},
  /* -- __propoffsets: memory offsets for each property in instance */
  {{
{list_meta_properties:    offsetof({meta.name}, {prop.name}){,}\n}\
  }}
{@endif}\
#endif
}};


/** Returns a pointer to hardcoded instance of {meta.name}. */
const DLiteInstance *get_{basename}()
{{
  DLiteInstance *inst = (DLiteInstance *)&{basename};
#ifdef HAVE_DLITE
  static int initialized=0;
  if (!initialized) {{
    inst->meta = dlite_meta_get("{meta.uri}");
    //if (dlite_instance_is_meta(inst))
    //  dlite_meta_init((DLiteMeta *)inst);
    initialized = 1;
  }}
#endif
  return inst;
}}
