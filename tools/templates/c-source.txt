/* -*- C -*-  (not really, but good for syntax highlighting) */

/* This file is generated with dlite-codegen {dlite.version} -- do not edit!
 *
 * Template: c-source.txt
 * Metadata: {_uri}
 *
 * This file instantiate a hardcoded instance of metadata {meta.name}.
 *
 * This allows you to use instances of {name} without first loading
 * the corresponding json file defining {name}.  For specialised instances
 * who's header is generated with the c-ext_header.txt template, one
 * should instantiate the corresponding metadata using the c-source.txt
 * template.
 *
 * Common variables that should be set when using this template:
 *
 *     meta.header
 *         Name of corresponding header file generated with c-header.txt
 *     _headersize (optional)
 *         Header size for extended header.  Typically specified using
 *         offsetof().
 *     _init (optional)
 *         Name of init() function
 *     _deinit (optional)
 *         Name of deinit() function
 */
\
{dim0={list_dimensions:{@if:{dim.i}=0}{dim.name}{@endif}\.}\.}\
{prop0={list_properties:{@if:{prop.i}=0}{prop.name}{@endif}\.}\.}\
\
#include <stddef.h>
\
{@if: {include?} }\
#include "{include}"
{@endif}\

{@if: {ismeta} }\
#include "{name%u}.h"
{@endif}\
{@if: {struct_name?} }\
#define {name}Struct {struct_name}
{@else}\
#ifdef {name}_HEAD
#define {name}Struct {name}{@if: {ismeta} }Schema{@endif}
#include "{name%u}_schema.h"
#else
#define {name}Struct {meta.name}
#include "{meta.name%u}.h"
#endif


{@if: {ismeta} }\
static DLiteDimension {name}_dimensions[] = {{
{list_meta_dimensions:  {{"{dim.name}", "{dim.descr}"}}{,}\n}\
}};
{list_meta_properties:\
{@if:{prop.ndims}!0}\
static char *{name%u}_prop_{prop.name}_dims[] = {{\
{prop.dims:"{dim.name}"{, }\.}\
}};
{@endif}\.}\
static DLiteProperty {name}_properties[] = {{
{list_meta_properties:  {{
    "{prop.name}", {@40}/* name */
    {prop.dtype},  {@40}/* type */
    {prop.size},   {@40}/* size */
    {prop.ndims},  {@40}/* ndims */
{@if:{prop.ndims}=0}\
    NULL,          {@40}/* dims */
{@else}\
    {name%u}_prop_{prop.name}_dims, {@40}/* dims */
{@endif}\
{@if:"{prop.unit}"}\
    "{prop.unit}", {@40}/* unit */
{@else}\
    NULL,          {@40}/* unit */
{@endif}\
{@if:"{prop.iri}"}\
    "{prop.iri}",  {@40}/* iri */
{@else}\
    NULL,          {@40}/* iri */
{@endif}\
{@if:"{prop.descr}"}\
    "{prop.descr}" {@40}/* description */
{@else}\
    NULL           {@40}/* description */
{@endif}\
  }}{,}
}\
}};
{@endif}\


static {name}Struct {name%u} = {{
#ifdef HAVE_DLITE
  /* -- {name}Struct_HEAD */
  "{_uuid}",  {@52}/* _uuid */
  "{_uri}",   {@52}/* _uri */
  1,                        {@52}/* _refcount */
  NULL,                     {@52}/* _meta */
  "{_iri}",                 {@52}/* _iri */
{@if:{ismeta}=1}
  {_ndimensions},           {@52}/* _ndimensions */
  {_nproperties},           {@52}/* _nproperties */
  {_nrelations},            {@52}/* _nrelations */

  {name}_dimensions,        {@52}/* _dimensions */
  {name}_properties,        {@52}/* _properties */
  NULL,                     {@52}/* _relations */

  offsetof({name}, {dim0}), {@52}/* _headersize */
  {_init},                  {@52}/* _init */
  {_deinit},                {@52}/* _deinit */

  {_npropdims},             {@52}/* _npropdims */
  {name%u}.__propdiminds,   {@52}/* _propdiminds */

  {_dimoffset},             {@52}/* _dimoffset */
  {name%u}.__propoffsets,   {@52}/* _propoffsets */
  {_reloffset},             {@52}/* _reloffset */
  {_propdimsoffset},        {@52}/* _propdimsoffset */
  {_propdimindsoffset},     {@52}/* _propdimindsoffset */
{@endif}\
#endif

  /* -- length of each dimension */
{list_meta_dimensions:  {dim.value}, {@52}/* {dim.name} */\n}\

  /* -- value of each property */
{list_meta_properties:  {prop.cvalue}, {@52}/* {prop.name} */\n}\

  /* -- value of each relation */
{list_meta_relations:  {{"{rel.s}", "{rel.p}", "{rel.o}", "{rel.id}"}}{,}\n}\

#ifdef HAVE_DLITE
  /* -- {name}Struct_TAIL */
  {{ {list_propdims:{propdim.n}{, }\.} }},{@52}/* __propdims */
{@if:{ismeta}=1}\
  {{ {list_properties:{prop.dimind}{, }\.} }},{@52}/* __propdiminds */
  {{                        {@52}/* __propoffsets */
{list_properties:    offsetof({name}, {prop.name}){,}\n}\
  }}
{@endif}\
#endif
}};


/** Returns a pointer to hardcoded instance of {meta.name}. */
const {name}Struct *get_{name%u}()
{{
   {name}Struct *inst = &{name%u};
#ifdef HAVE_DLITE
  static int initialized=0;
  if (!initialized) {{
    inst->meta = dlite_meta_get("{meta.uri}");
    /* In case {name} is extended, we must recalculate all offsets
       from _headersize */
    //if (dlite_instance_is_meta((DLiteInstance *)inst))
    // dlite_meta_init((DLiteMeta *)inst);
    initialized = 1;
  }}
#endif
  return inst;
}}
